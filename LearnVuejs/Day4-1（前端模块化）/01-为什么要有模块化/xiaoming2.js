//第一种方式
//
// 然后小明可能又创建了一个js文件   然后他知道自己之前还定义过flag这个变量 而且还知道定义为true的
// 这个时候小明可能会做一些事情
// if (flag){  //当flag为true的时候打印一句话  因为小明知道自己之前给flag定义的就是true
//   console.log('小明是天才');
//   // 所以按他的想法来说这句话应该是打印的
// }
// 然而当写完之后去页面调试了发现，这句话并没有打印  然后他就会回来检查自己的代码有没有错
// 其实这个代码没有任何错 只是因为全局变量的命名相同小红也在她那里命名了一个和小明一样的变量
// 且她将flag改为false了 所以只后小明调用出来的flag就是false而不是他之前定义的true 因为这个
// js是反正小红下面引用的所以是运行了小红的脚本后再运行这个脚本所以flag在用之前就已经通过小红的
// 脚本变成false了所以页面上也不会打印，这也不是小明代码的问题而是两个人命名了同一个全局变量
// 冲突的问题  在真实开发中，如果每个人的代码量很多，那么是很难找出来这个问题的
//  我们要怎样来做才能避免全局变量同名的问题呢？ 可以通过闭包的方式


//第二种方式
// ;(function () {
//   // 我们通过这种方式的话就会使代码不可复用 小明用不了自己第一次定义在第一个js文件里的flag
//   // 如果我们想实现 避免同名冲突也避免代码不可复用 怎么做呢？
//   // 1.想使用flag
//   if (flag){
//     console.log('小明是天才');
//
//   }
//
//   // 2.想使用sum函数
//
// })()

// 这个使用就要用到我们模块化的方式了

// 第三种方式 模块化

;(function () {
  // 1.想使用flag
//既然定义的moduleA这个是个全局变量 我们就可以这样使用了  通过这个模块对象
//   我们拿到这个moduleA模块对象点出flag就拿到了我们定义的flag了 这样就可复用了
  if (moduleA.flag){
    console.log('小明是天才');
  }
  // 2.想使用sum函数
  console.log(moduleA.sum(10, 20));
})()

// 这样只要模块间命名和别的模块的名字不同就行了 我们就给各自需要调用的变量放到自己定义的模块里
// 我们需要调用直接调用模块里定义的变量就行了 只要两个人模块的命名不同就不会出现变量命名冲突
// 的问题了  在真实的开发中也只需注意模块的命名而不用居于里面小组件的名字这样就方便很多
// 这就是早期实现自己的模块化   而现在不需要这样做了 因为已经有很多人做出了模块化的规范了
// 只要别人在它的基础之上进行模块化的开发就行了